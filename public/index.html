<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>XSLT Quick Reference â€” v0.9.8</title>
<link rel="stylesheet" href="css/docset.css">
<script src="scripts/application.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1">
<!--
Note: This file is generated by XSLT from the elements.xml file.
So you definitely shouldn't be editing it, or you'll end up sad...
			-->
</head>
<body id="toc" class="language-markup">
<section id="xslt-elements"><h1>XSLT elements</h1>
<section class="element with-sample" id="apply-imports"><h1><a href="#apply-imports">&lt;xsl:apply-imports&gt;</a></h1>
<div class="desc">
			<p>
				This is used to allow the processor to process any imported templates that
				matches the context node
			</p>
		</div>
<div class="sample"><pre><code>&lt;!-- We need to wrap every movie element --&gt;
&lt;xsl:template match="movie"&gt;
  &lt;div class="movie"&gt;
    &lt;!-- Process the imported template for movie elements --&gt;
    &lt;xsl:apply-imports /&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;</code></pre></div></section><section class="element" id="apply-templates"><h1><a href="#apply-templates">&lt;xsl:apply-templates&gt;</a></h1>
<div class="desc">
			<p>
				Collects the nodes specified by the <var class="attr-ref">select</var> attribute and
				starts processing them using matching templates.
			</p>
			<p>
				Using the <var class="attr-ref">mode</var> attribute restricts the applied templates to
				only those with an identical mode attribute.
			</p>
			<p class="note">
				If no select attribute is present, it defaults to "*", i.e. the children
				of the current node.
			</p>
		</div>
<ul class="content">
<li class="attr-ref">select <span class="type"><span class="general">expression</span></span> <span class="type"><span class="general"></span></span>
</li>
<li class="attr-ref">mode <span class="type"><span class="general">string</span></span>
</li>
</ul>
<ul class="content">
<li class="elem-ref"><a href="#sort">&lt;xsl:sort&gt;</a></li>
<li class="elem-ref"><a href="#with-param">&lt;xsl:with-param&gt;</a></li>
</ul></section><section class="element" id="attribute"><h1><a href="#attribute">&lt;xsl:attribute&gt;</a></h1>
<div class="desc">
			<p>
				Generates an attribute on the element being output. Must precede any
				content generated for an element (i.e.: text, child elements, comments etc.)
			</p>
			<p class="note">
				Can be used to override an attribute you've already set, as
				duplicate attribute names are not allowed in XML.
			</p>
		</div>
<ul class="content">
<li class="attr-ref required">name <span class="type"><span class="general">string</span></span>
</li>
<li class="attr-ref">namespace <span class="type"><span class="general">URI</span></span>
</li>
</ul>
<ul class="content">
<li class="elem-ref"><a href="#if">&lt;xsl:if&gt;</a></li>
<li class="elem-ref"><a href="#choose">&lt;xsl:choose&gt;</a></li>
<li class="elem-ref"><a href="#for-each">&lt;xsl:for-each&gt;</a></li>
<li class="elem-ref"><a href="#value-of">&lt;xsl:value-of&gt;</a></li>
<li class="elem-ref"><a href="#comment">&lt;xsl:comment&gt;</a></li>
<li class="elem-ref"><a href="#text">&lt;xsl:text&gt;</a></li>
<li class="elem-ref"><a href="#param">&lt;xsl:param&gt;</a></li>
<li class="elem-ref"><a href="#variable">&lt;xsl:variable&gt;</a></li>
<li class="elem-ref"><a href="#number">&lt;xsl:number&gt;</a></li>
<li class="elem-ref"><a href="#apply-templates">&lt;xsl:apply-templates&gt;</a></li>
<li class="elem-ref"><a href="#call-template">&lt;xsl:call-template&gt;</a></li>
<li class="elem-ref"><a href="#processing-instruction">&lt;xsl:processing-instruction&gt;</a></li>
<li class="elem-ref"><a href="#apply-imports">&lt;xsl:apply-imports&gt;</a></li>
<li class="elem-ref"><a href="#fallback">&lt;xsl:fallback&gt;</a></li>
</ul></section><section class="element" id="attribute-set"><h1><a href="#attribute-set">&lt;xsl:attribute-set&gt;</a></h1>
<div class="desc">
			<p>
				Used to build a set of attributes for reuse on multiple output elements.
				Use the special <var class="attr-ref">xsl:use-attribute-sets</var> attribute on any literal output element,
				to tell the processor to generate these attributes on the element.
			</p>
		</div>
<ul class="content"><li class="attr-ref required">name <span class="type"><span class="general">string</span></span>
</li></ul>
<ul class="content"><li class="elem-ref"><a href="#attribute">&lt;xsl:attribute&gt;</a></li></ul></section><section class="element with-sample" id="call-template"><h1><a href="#call-template">&lt;xsl:call-template&gt;</a></h1>
<div class="desc">
			<p>
				Explicitly call a named <a href="#template" class="elem-ref">template</a> (a template with a name attribute).
				The template will execute with the context at the point of this instruction.
			</p>
			<p>
				If the template accepts arguments (parameters), use the <a href="#with-param" class="elem-ref">with-param</a> element
				to supply values to those.
			</p>
		</div>
<div class="sample"><pre><code>&lt;!-- Simple --&gt;
&lt;xsl:call-template name="headers" /&gt;

&lt;!-- With argument --&gt;
&lt;xsl:call-template name="fibonacci"&gt;
	&lt;xsl:with-param name="from" select="13" /&gt;
&lt;/xsl:call-template&gt;</code></pre></div>
<ul class="content"><li class="attr-ref required">name <span class="type"><span class="general">string</span></span>
</li></ul>
<ul class="content"><li class="elem-ref"><a href="#with-param">&lt;xsl:with-param&gt;</a></li></ul></section><section class="element" id="choose"><h1><a href="#choose">&lt;xsl:choose&gt;</a></h1>
<div class="desc">
			<p>
				Similar to switch and if/elseif statements in other languages, this is used
				to choose between one or more outcomes. It's a bit verbose, and for simple
				A/B scenarios it's often possible to handle the logic in a single XPath
				statement instead.
			</p>
			<p>
				Only the first <a href="#when" class="elem-ref">when</a> where the test returns <var class="attr-ref">true()</var> will be executed
				(or, if no <a href="#when" class="elem-ref">when</a>-statements succeed, the contents of <a href="#otherwise" class="elem-ref">otherwise</a>, if present).
			</p>
		</div>
<ul class="content">
<li class="elem-ref"><a href="#when">&lt;xsl:when&gt;</a></li>
<li class="elem-ref"><a href="#otherwise">&lt;xsl:otherwise&gt;</a></li>
</ul></section><section class="element with-sample" id="comment"><h1><a href="#comment">&lt;xsl:comment&gt;</a></h1>
<div class="desc">
			<p>Use this to generate a comment in the output.</p>
			<p class="note">
				This is necessary because a regular comment is in fact just
				a comment in the stylesheet, which is used to comment the code,
				and is in fact stripped by the XML parser before the XSLT processor
				gets the stylesheet.
			</p>
		</div>
<div class="sample"><pre><code>&lt;xsl:comment&gt;This file is auto-generated&lt;/xsl:comment&gt;</code></pre></div></section><section class="element" id="decimal-format"><h1><a href="#decimal-format">&lt;xsl:decimal-format&gt;</a></h1>
<div class="desc">
			<p>
				Defines a named custom format for use with the <a href="#number" class="elem-ref">number</a> instruction
				and the <a href="#format-number" class="func-ref">format-number()</a> function.
			</p>
		</div>
<ul class="content">
<li class="attr-ref">name <span class="type"><span class="general">string</span></span>
</li>
<li class="attr-ref">decimal-separator <span class="type"><span class="general">char</span></span>
</li>
<li class="attr-ref">grouping-separator <span class="type"><span class="general">char</span></span>
</li>
<li class="attr-ref">infinity <span class="type"><span class="general">string</span></span>
</li>
<li class="attr-ref">minus-sign <span class="type"><span class="general">char</span></span>
</li>
<li class="attr-ref">NaN <span class="type"><span class="general">string</span></span>
</li>
<li class="attr-ref">percent <span class="type"><span class="general">char</span></span>
</li>
<li class="attr-ref">per-mille <span class="type"><span class="general">char</span></span>
</li>
<li class="attr-ref">zero-digit <span class="type"><span class="general">char</span></span>
</li>
<li class="attr-ref">digit <span class="type"><span class="general">char</span></span>
</li>
<li class="attr-ref">pattern-separator <span class="type"><span class="general">char</span></span>
</li>
</ul></section><section class="element" id="element"><h1><a href="#element">&lt;xsl:element&gt;</a></h1>
<div class="desc">
			<p>
				Creates an element with a specific <var class="attr-ref">name</var>.
			</p>
			<p>
				Only necessary if you don't know the name of the element (e.g. if it's computed, like <code>&lt;xsl:element name="h{$level}"&gt;</code>),
				or if you need to create the element in a specific namespace. Otherwise it's much better to just use the
				element tag directly (i.e., just use <code>&lt;div&gt;</code>
				instead of <code>&lt;xsl:element name="div"&gt;</code>).
			</p>
		</div>
<ul class="content">
<li class="attr-ref">name <span class="type"><span class="general">string</span></span>
</li>
<li class="attr-ref">namespace <span class="type"><span class="general">URI</span></span>
</li>
</ul>
<ul class="content">
<li class="elem-ref"><a href="#if">&lt;xsl:if&gt;</a></li>
<li class="elem-ref"><a href="#choose">&lt;xsl:choose&gt;</a></li>
<li class="elem-ref"><a href="#for-each">&lt;xsl:for-each&gt;</a></li>
<li class="elem-ref"><a href="#value-of">&lt;xsl:value-of&gt;</a></li>
<li class="elem-ref"><a href="#comment">&lt;xsl:comment&gt;</a></li>
<li class="elem-ref"><a href="#text">&lt;xsl:text&gt;</a></li>
<li class="elem-ref"><a href="#param">&lt;xsl:param&gt;</a></li>
<li class="elem-ref"><a href="#variable">&lt;xsl:variable&gt;</a></li>
<li class="elem-ref"><a href="#number">&lt;xsl:number&gt;</a></li>
<li class="elem-ref"><a href="#apply-templates">&lt;xsl:apply-templates&gt;</a></li>
<li class="elem-ref"><a href="#call-template">&lt;xsl:call-template&gt;</a></li>
<li class="elem-ref"><a href="#processing-instruction">&lt;xsl:processing-instruction&gt;</a></li>
<li class="elem-ref"><a href="#apply-imports">&lt;xsl:apply-imports&gt;</a></li>
<li class="elem-ref"><a href="#fallback">&lt;xsl:fallback&gt;</a></li>
</ul></section><section class="element" id="fallback"><h1><a href="#fallback">&lt;xsl:fallback&gt;</a></h1>
<div class="desc">
			<p>
				The contents of the fallback instruction is only instantiated if its
				parent element is not supported by the XSLT processor. Rarely used.
			</p>
		</div>
<ul class="content">
<li class="elem-ref"><a href="#if">&lt;xsl:if&gt;</a></li>
<li class="elem-ref"><a href="#choose">&lt;xsl:choose&gt;</a></li>
<li class="elem-ref"><a href="#for-each">&lt;xsl:for-each&gt;</a></li>
<li class="elem-ref"><a href="#value-of">&lt;xsl:value-of&gt;</a></li>
<li class="elem-ref"><a href="#comment">&lt;xsl:comment&gt;</a></li>
<li class="elem-ref"><a href="#text">&lt;xsl:text&gt;</a></li>
<li class="elem-ref"><a href="#param">&lt;xsl:param&gt;</a></li>
<li class="elem-ref"><a href="#variable">&lt;xsl:variable&gt;</a></li>
<li class="elem-ref"><a href="#number">&lt;xsl:number&gt;</a></li>
<li class="elem-ref"><a href="#apply-templates">&lt;xsl:apply-templates&gt;</a></li>
<li class="elem-ref"><a href="#call-template">&lt;xsl:call-template&gt;</a></li>
<li class="elem-ref"><a href="#processing-instruction">&lt;xsl:processing-instruction&gt;</a></li>
</ul></section><section class="element" id="for-each"><h1><a href="#for-each">&lt;xsl:for-each&gt;</a></h1>
<div class="desc">
			<p>
				Almost an alias for <a href="#apply-templates" class="elem-ref">apply-templates</a> in that it also collects a set of nodes
				for processing, but all nodes will be processed using the same (embedded) template.
			</p>
		</div>
<ul class="content"><li class="attr-ref required">select <span class="type"><span class="general">expression</span></span> <span class="type"><span class="general"></span></span>
</li></ul>
<ul class="content">
<li class="elem-ref"><a href="#sort">&lt;xsl:sort&gt;</a></li>
<li class="elem-ref"><a href="#if">&lt;xsl:if&gt;</a></li>
<li class="elem-ref"><a href="#choose">&lt;xsl:choose&gt;</a></li>
<li class="elem-ref"><a href="#for-each">&lt;xsl:for-each&gt;</a></li>
<li class="elem-ref"><a href="#value-of">&lt;xsl:value-of&gt;</a></li>
<li class="elem-ref"><a href="#comment">&lt;xsl:comment&gt;</a></li>
<li class="elem-ref"><a href="#text">&lt;xsl:text&gt;</a></li>
<li class="elem-ref"><a href="#param">&lt;xsl:param&gt;</a></li>
<li class="elem-ref"><a href="#variable">&lt;xsl:variable&gt;</a></li>
<li class="elem-ref"><a href="#number">&lt;xsl:number&gt;</a></li>
<li class="elem-ref"><a href="#apply-templates">&lt;xsl:apply-templates&gt;</a></li>
<li class="elem-ref"><a href="#call-template">&lt;xsl:call-template&gt;</a></li>
<li class="elem-ref"><a href="#processing-instruction">&lt;xsl:processing-instruction&gt;</a></li>
<li class="elem-ref"><a href="#apply-imports">&lt;xsl:apply-imports&gt;</a></li>
<li class="elem-ref"><a href="#fallback">&lt;xsl:fallback&gt;</a></li>
</ul></section><section class="element" id="if"><h1><a href="#if">&lt;xsl:if&gt;</a></h1>
<ul class="content"><li class="attr-ref required">test <span class="type"><span class="general">condition</span></span>
</li></ul>
<ul class="content">
<li class="elem-ref"><a href="#if">&lt;xsl:if&gt;</a></li>
<li class="elem-ref"><a href="#choose">&lt;xsl:choose&gt;</a></li>
<li class="elem-ref"><a href="#for-each">&lt;xsl:for-each&gt;</a></li>
<li class="elem-ref"><a href="#value-of">&lt;xsl:value-of&gt;</a></li>
<li class="elem-ref"><a href="#comment">&lt;xsl:comment&gt;</a></li>
<li class="elem-ref"><a href="#text">&lt;xsl:text&gt;</a></li>
<li class="elem-ref"><a href="#param">&lt;xsl:param&gt;</a></li>
<li class="elem-ref"><a href="#variable">&lt;xsl:variable&gt;</a></li>
<li class="elem-ref"><a href="#number">&lt;xsl:number&gt;</a></li>
<li class="elem-ref"><a href="#apply-templates">&lt;xsl:apply-templates&gt;</a></li>
<li class="elem-ref"><a href="#call-template">&lt;xsl:call-template&gt;</a></li>
<li class="elem-ref"><a href="#processing-instruction">&lt;xsl:processing-instruction&gt;</a></li>
<li class="elem-ref"><a href="#apply-imports">&lt;xsl:apply-imports&gt;</a></li>
<li class="elem-ref"><a href="#fallback">&lt;xsl:fallback&gt;</a></li>
</ul></section><section class="element" id="import"><h1><a href="#import">&lt;xsl:import&gt;</a></h1>
<div class="desc">
			<p class="note">
				The <a href="#import" class="elem-ref">import</a> statement(s) <strong>must</strong> appear before
				any other child node of the main stylesheet.
			</p>
		</div>
<ul class="content"><li class="attr-ref required">href <span class="type"><span class="general">URI</span></span>
</li></ul></section><section class="element" id="include"><h1><a href="#include">&lt;xsl:include&gt;</a></h1>
<ul class="content"><li class="attr-ref required">href <span class="type"><span class="general">URI</span></span>
</li></ul></section><section class="element" id="key"><h1><a href="#key">&lt;xsl:key&gt;</a></h1>
<div class="desc">
			<p>
				Creates a named index of elements matching the expression in the <var class="attr-ref">match</var> attribute.
				The value retrieved from the <var class="attr-ref">use</var> attribute is stored as the index value.
			</p>
			<p class="note">
				To retrieve nodes from the index, use the XPath <a href="#key-function" class="func-ref">key()</a> function.
			</p>
		</div>
<ul class="content">
<li class="attr-ref required">match <span class="type"><span class="general">pattern</span></span>
</li>
<li class="attr-ref required">name <span class="type"><span class="general">string</span></span>
</li>
<li class="attr-ref required">use <span class="type"><span class="general">expression</span></span>
</li>
</ul></section><section class="element" id="message"><h1><a href="#message">&lt;xsl:message&gt;</a></h1>
<div class="desc">
			<p>
				Used to output debugging/logging info to <code>stdout</code> during
				transformation. If the <var class="attr-ref">terminate</var> attribute is set to <code>yes</code>,
				the transformation will terminate.
			</p>
		</div>
<ul class="content"><li class="attr-ref">terminate<span class="type"> (<span class="enum">yes|no</span>)</span>
</li></ul></section><section class="element" id="namespace-alias"><h1><a href="#namespace-alias">&lt;xsl:namespace-alias&gt;</a></h1>
<div class="desc">
			<p>
				Assigns an alias to an existing prefix so it's possible to generate literal result elements
				that would otherwise be interpreted as instructions (e.g. when generating an XSLT stylesheet).
			</p>
		</div>
<ul class="content">
<li class="attr-ref required">stylesheet-prefix <span class="type"><span class="general">string</span></span>
</li>
<li class="attr-ref required">result-prefix <span class="type"><span class="general">string</span></span>
</li>
</ul></section><section class="element" id="number"><h1><a href="#number">&lt;xsl:number&gt;</a></h1>
<ul class="content">
<li class="attr-ref">count <span class="type"><span class="general">expression</span></span>
</li>
<li class="attr-ref">level<span class="type"> (<span class="enum">single|multiple|any</span>)</span>
</li>
<li class="attr-ref">from <span class="type"><span class="general">expression</span></span>
</li>
<li class="attr-ref">value <span class="type"><span class="general">expression</span></span>
</li>
<li class="attr-ref">format <span class="type"><span class="general">string</span></span>
</li>
<li class="attr-ref">lang <span class="type"><span class="general">string</span></span>
</li>
<li class="attr-ref">letter-value<span class="type"> (<span class="enum">alphabetic|traditional</span>)</span>
</li>
<li class="attr-ref">grouping-separator <span class="type"><span class="general">char</span></span>
</li>
<li class="attr-ref">grouping-size <span class="type"><span class="general">number</span></span>
</li>
</ul></section><section class="element" id="otherwise"><h1><a href="#otherwise">&lt;xsl:otherwise&gt;</a></h1>
<div class="desc">
			<p>
				Part of a <a href="#choose" class="elem-ref">choose</a> construct - executed if none of the preceding
				<a href="#when" class="elem-ref">when</a> statements returned <var class="attr-ref">true()</var>.
			</p>
		</div>
<ul class="content">
<li class="elem-ref"><a href="#if">&lt;xsl:if&gt;</a></li>
<li class="elem-ref"><a href="#choose">&lt;xsl:choose&gt;</a></li>
<li class="elem-ref"><a href="#for-each">&lt;xsl:for-each&gt;</a></li>
<li class="elem-ref"><a href="#value-of">&lt;xsl:value-of&gt;</a></li>
<li class="elem-ref"><a href="#comment">&lt;xsl:comment&gt;</a></li>
<li class="elem-ref"><a href="#text">&lt;xsl:text&gt;</a></li>
<li class="elem-ref"><a href="#param">&lt;xsl:param&gt;</a></li>
<li class="elem-ref"><a href="#variable">&lt;xsl:variable&gt;</a></li>
<li class="elem-ref"><a href="#number">&lt;xsl:number&gt;</a></li>
<li class="elem-ref"><a href="#apply-templates">&lt;xsl:apply-templates&gt;</a></li>
<li class="elem-ref"><a href="#call-template">&lt;xsl:call-template&gt;</a></li>
<li class="elem-ref"><a href="#processing-instruction">&lt;xsl:processing-instruction&gt;</a></li>
<li class="elem-ref"><a href="#apply-imports">&lt;xsl:apply-imports&gt;</a></li>
<li class="elem-ref"><a href="#fallback">&lt;xsl:fallback&gt;</a></li>
</ul></section><section class="element" id="output"><h1><a href="#output">&lt;xsl:output&gt;</a></h1>
<ul class="content">
<li class="attr-ref">method<span class="type"> (<span class="enum">html|xml|text</span>)</span>
</li>
<li class="attr-ref">indent<span class="type"> (<span class="enum">yes|no</span>)</span>
</li>
<li class="attr-ref">omit-xml-declaration<span class="type"> (<span class="enum">yes|no</span>)</span>
</li>
<li class="attr-ref">doctype-public <span class="type"><span class="general">URI</span></span>
</li>
<li class="attr-ref">doctype-system <span class="type"><span class="general">URI</span></span>
</li>
<li class="attr-ref">cdata-section-elements <span class="type"><span class="nmtokens">list of names</span></span>
</li>
</ul></section><section class="element" id="param"><h1><a href="#param">&lt;xsl:param&gt;</a></h1>
<div class="desc">
			<p>
				Defines a value that can be used in many places, which should be easily changeable
				from e.g. the top of the file. Once defined, a parameter can be used by prefixing the name
				with a dollar-sign, e.g. <code>&lt;xsl:value-of select="$primary-color"&gt;</code>
				or <code>&lt;div class="{$selected-class}"&gt;</code>.
			</p>
			<p>
				A parameter is very similar to a <a href="#variable" class="elem-ref">variable</a>, and none of them can be changed
				within the same transformation.
			</p>
			<p class="note">
				The difference between a parameter and a <a href="#variable" class="elem-ref">variable</a> is that a parameter can be set
				from the XSLT Processor when invoking the transform.
			</p>
		</div>
<ul class="content">
<li class="attr-ref required">name <span class="type"><span class="general">string</span></span>
</li>
<li class="attr-ref">select <span class="type"><span class="general"></span></span>
</li>
</ul>
<ul class="content">
<li class="elem-ref"><a href="#if">&lt;xsl:if&gt;</a></li>
<li class="elem-ref"><a href="#choose">&lt;xsl:choose&gt;</a></li>
<li class="elem-ref"><a href="#for-each">&lt;xsl:for-each&gt;</a></li>
<li class="elem-ref"><a href="#value-of">&lt;xsl:value-of&gt;</a></li>
<li class="elem-ref"><a href="#text">&lt;xsl:text&gt;</a></li>
<li class="elem-ref"><a href="#number">&lt;xsl:number&gt;</a></li>
</ul></section><section class="element" id="preserve-space"><h1><a href="#preserve-space">&lt;xsl:preserve-space&gt;</a></h1>
<div class="desc">
			<p>
				Instructs the processor to preserve white-space nodes from specific
				elements in the source document before they're handled by XSLT.
			</p>
			<p class="note">
				The default behavior is to preserve white-space, so this element is provided
				so you can preserve specific elements' white-space, in case <a href="#strip-space" class="elem-ref">strip-space</a>
				has been set to "all others" ("*").
			</p>
		</div>
<ul class="content"><li class="attr-ref">elements <span class="type"><span class="nmtokens">list of names</span></span>
</li></ul></section><section class="element with-sample" id="processing-instruction"><h1><a href="#processing-instruction">&lt;xsl:processing-instruction&gt;</a></h1>
<div class="desc">
			<p>
				Generates a <em>Processing Instruction</em> in the output; usually used for
				adding some kind of machine-info to the file.
			</p>
			<p>
				A processing instruction can be selected in an XPath expression using the <a href="#processing-instruction-function" class="func-ref">processing-instruction()</a> function.
			</p>
			<p class="note">Although the <var class="attr-ref">name</var> attribute isn't required, no output
			will be generated if it's missing.</p>
		</div>
<div class="sample"><pre><code>&lt;!-- Generates something like this: &lt;?doc-version v0.9.3.4 ?&gt; --&gt;
&lt;xsl:processing-instruction name="doc-version"&gt;
  &lt;xsl:value-of select="$version" /&gt;
&lt;/xsl:processing-instruction&gt;</code></pre></div>
<ul class="content"><li class="attr-ref">name <span class="type"><span class="general">string</span></span>
</li></ul></section><section class="element" id="sort"><h1><a href="#sort">&lt;xsl:sort&gt;</a></h1>
<div class="desc">
			<p>
				If present, this <strong>must</strong> be the first element inside a <a href="#for-each" class="elem-ref">for-each</a> or an
				<a href="#apply-templates" class="elem-ref">apply-templates</a> instruction.
			</p>
			<p class="note">
				Multiple sort elements are allowed.
			</p>
		</div>
<ul class="content">
<li class="attr-ref">select <span class="type"><span class="general">expression</span></span> <span class="type"><span class="general"></span></span>
</li>
<li class="attr-ref">data-type<span class="type"> (<span class="enum">text|number</span>)</span>
</li>
<li class="attr-ref">order<span class="type"> (<span class="enum">ascending|descending</span>)</span>
</li>
<li class="attr-ref">case-order<span class="type"> (<span class="enum">upper-first|lower-first</span>)</span>
</li>
<li class="attr-ref">lang <span class="type"><span class="general">string</span></span>
</li>
</ul></section><section class="element" id="strip-space"><h1><a href="#strip-space">&lt;xsl:strip-space&gt;</a></h1>
<div class="desc">
			<p>
				Instructs the processor to remove all white-space nodes from specific
				elements in the source document before they're handled by XSLT.
			</p>
			<p class="note">
				You can use the value "*" to strip space from all elements.
			</p>
		</div>
<ul class="content"><li class="attr-ref">elements <span class="type"><span class="nmtokens">list of names</span></span>
</li></ul></section><section class="element" id="stylesheet"><h1><a href="#stylesheet">&lt;xsl:stylesheet&gt;</a></h1>
<ul class="content">
<li class="attr-ref required">version<span class="type"> (<span class="enum">1.0</span>)</span>
</li>
<li class="attr-ref">exclude-result-prefixes <span class="type"><span class="nmtokens">list of names</span></span>
</li>
<li class="attr-ref">extension-element-prefixes <span class="type"><span class="nmtokens">list of names</span></span>
</li>
</ul>
<ul class="content">
<li class="elem-ref"><a href="#attribute-set">&lt;xsl:attribute-set&gt;</a></li>
<li class="elem-ref"><a href="#key">&lt;xsl:key&gt;</a></li>
<li class="elem-ref"><a href="#namespace-alias">&lt;xsl:namespace-alias&gt;</a></li>
<li class="elem-ref"><a href="#import">&lt;xsl:import&gt;</a></li>
<li class="elem-ref"><a href="#include">&lt;xsl:include&gt;</a></li>
<li class="elem-ref"><a href="#output">&lt;xsl:output&gt;</a></li>
</ul></section><section class="element" id="template"><h1><a href="#template">&lt;xsl:template&gt;</a></h1>
<div class="desc">
			<p>
				A template defines a chunk of output. When using the <var class="attr-ref">match</var> attribute,
				it can only be invoked by an <a href="#apply-templates" class="elem-ref">apply-templates</a> instruction (which can process multiple
				elements and their templates in a single operation), and is guaranteed to have the context of
				an element matching the pattern in the <var class="attr-ref">match</var> attribute.
			</p>
			<p>
				When using the <var class="attr-ref">name</var> attribute, the template can be manually invoked by
				a <a href="#call-template" class="elem-ref">call-template</a> instruction, thus resembling a <em>sub-routine</em> in other
				languages.
			</p>
			<p>
				The <var class="attr-ref">mode</var> attribute facilitates multiple outputs for the same element, e.g. if
				an <code>&lt;article&gt;</code> needs a short version for the Table of Contents at
				the top of the output, and a longer version for the actual article content.
			</p>
			<p class="note">
				It's perfectly valid to have both a <var class="attr-ref">match</var> and a <var class="attr-ref">name</var> attribute on a
				template, if it makes sense. But you're required to use at least one of them.
			</p>
		</div>
<ul class="content">
<li class="attr-ref">match <span class="type"><span class="general">pattern</span></span>
</li>
<li class="attr-ref">name <span class="type"><span class="general">string</span></span>
</li>
<li class="attr-ref">mode <span class="type"><span class="general">string</span></span>
</li>
<li class="attr-ref">priority <span class="type"><span class="general">number</span></span>
</li>
</ul>
<ul class="content">
<li class="elem-ref"><a href="#if">&lt;xsl:if&gt;</a></li>
<li class="elem-ref"><a href="#choose">&lt;xsl:choose&gt;</a></li>
<li class="elem-ref"><a href="#for-each">&lt;xsl:for-each&gt;</a></li>
<li class="elem-ref"><a href="#value-of">&lt;xsl:value-of&gt;</a></li>
<li class="elem-ref"><a href="#comment">&lt;xsl:comment&gt;</a></li>
<li class="elem-ref"><a href="#text">&lt;xsl:text&gt;</a></li>
<li class="elem-ref"><a href="#param">&lt;xsl:param&gt;</a></li>
<li class="elem-ref"><a href="#variable">&lt;xsl:variable&gt;</a></li>
<li class="elem-ref"><a href="#number">&lt;xsl:number&gt;</a></li>
<li class="elem-ref"><a href="#apply-templates">&lt;xsl:apply-templates&gt;</a></li>
<li class="elem-ref"><a href="#call-template">&lt;xsl:call-template&gt;</a></li>
<li class="elem-ref"><a href="#processing-instruction">&lt;xsl:processing-instruction&gt;</a></li>
<li class="elem-ref"><a href="#apply-imports">&lt;xsl:apply-imports&gt;</a></li>
<li class="elem-ref"><a href="#fallback">&lt;xsl:fallback&gt;</a></li>
</ul></section><section class="element" id="text"><h1><a href="#text">&lt;xsl:text&gt;</a></h1>
<ul class="content"><li class="attr-ref">disable-output-escaping<span class="type"> (<span class="enum">yes|no</span>)</span>
</li></ul></section><section class="element" id="transform"><h1><a href="#transform">&lt;xsl:transform&gt;</a></h1>
<div class="desc">
			<p>This is an alias for the <a href="#stylesheet" class="elem-ref">stylesheet</a> element - almost never used.</p>
		</div>
<ul class="content"><li class="attr-ref required">version<span class="type"> (<span class="enum">1.0</span>)</span>
</li></ul>
<ul class="content">
<li class="elem-ref"><a href="#attribute-set">&lt;xsl:attribute-set&gt;</a></li>
<li class="elem-ref"><a href="#key">&lt;xsl:key&gt;</a></li>
<li class="elem-ref"><a href="#namespace-alias">&lt;xsl:namespace-alias&gt;</a></li>
<li class="elem-ref"><a href="#import">&lt;xsl:import&gt;</a></li>
<li class="elem-ref"><a href="#include">&lt;xsl:include&gt;</a></li>
<li class="elem-ref"><a href="#output">&lt;xsl:output&gt;</a></li>
</ul></section><section class="element" id="value-of"><h1><a href="#value-of">&lt;xsl:value-of&gt;</a></h1>
<div class="desc">
			<p>
				This is used to generate a string value in the output by selecting something from the
				input document. The <var class="attr-ref">select</var> attribute is an XPath expression - if it selects
				a node set, <em>only the string value of the first node in the set will be output.</em>
			</p>
			<p class="note">
				Though the <var class="attr-ref">disable-output-escaping</var> attribute can be used to output text as
				HTML or XML, it is thus also possible to generate invalid XML - so be sure to know what
				the source contains before blindly transferring it to the output document.
			</p>
		</div>
<ul class="content">
<li class="attr-ref required">select <span class="type"><span class="general">expression</span></span> <span class="type"><span class="general"></span></span>
</li>
<li class="attr-ref">disable-output-escaping<span class="type"> (<span class="enum">yes|no</span>)</span>
</li>
</ul></section><section class="element" id="variable"><h1><a href="#variable">&lt;xsl:variable&gt;</a></h1>
<ul class="content">
<li class="attr-ref required">name <span class="type"><span class="general">string</span></span>
</li>
<li class="attr-ref">select <span class="type"><span class="general">expression</span></span> <span class="type"><span class="general"></span></span>
</li>
</ul>
<ul class="content">
<li class="elem-ref"><a href="#if">&lt;xsl:if&gt;</a></li>
<li class="elem-ref"><a href="#choose">&lt;xsl:choose&gt;</a></li>
<li class="elem-ref"><a href="#for-each">&lt;xsl:for-each&gt;</a></li>
<li class="elem-ref"><a href="#value-of">&lt;xsl:value-of&gt;</a></li>
<li class="elem-ref"><a href="#text">&lt;xsl:text&gt;</a></li>
<li class="elem-ref"><a href="#number">&lt;xsl:number&gt;</a></li>
</ul></section><section class="element" id="when"><h1><a href="#when">&lt;xsl:when&gt;</a></h1>
<div class="desc">
			<p>
				Used in the <a href="#choose" class="elem-ref">choose</a> construct to test a condition and
				if <var class="attr-ref">true()</var>, execute the contents.
			</p>
			<p>
				The condition in the test attribute is implicitly wrapped in a <var class="attr-ref">boolean()</var>
				function to always return <var class="attr-ref">true()</var> or <var class="attr-ref">false()</var>.
			</p>
		</div>
<ul class="content"><li class="attr-ref required">test <span class="type"><span class="general">condition</span></span>
</li></ul>
<ul class="content">
<li class="elem-ref"><a href="#if">&lt;xsl:if&gt;</a></li>
<li class="elem-ref"><a href="#choose">&lt;xsl:choose&gt;</a></li>
<li class="elem-ref"><a href="#for-each">&lt;xsl:for-each&gt;</a></li>
<li class="elem-ref"><a href="#value-of">&lt;xsl:value-of&gt;</a></li>
<li class="elem-ref"><a href="#comment">&lt;xsl:comment&gt;</a></li>
<li class="elem-ref"><a href="#text">&lt;xsl:text&gt;</a></li>
<li class="elem-ref"><a href="#param">&lt;xsl:param&gt;</a></li>
<li class="elem-ref"><a href="#variable">&lt;xsl:variable&gt;</a></li>
<li class="elem-ref"><a href="#number">&lt;xsl:number&gt;</a></li>
<li class="elem-ref"><a href="#apply-templates">&lt;xsl:apply-templates&gt;</a></li>
<li class="elem-ref"><a href="#call-template">&lt;xsl:call-template&gt;</a></li>
<li class="elem-ref"><a href="#processing-instruction">&lt;xsl:processing-instruction&gt;</a></li>
<li class="elem-ref"><a href="#apply-imports">&lt;xsl:apply-imports&gt;</a></li>
<li class="elem-ref"><a href="#fallback">&lt;xsl:fallback&gt;</a></li>
</ul></section><section class="element" id="with-param"><h1><a href="#with-param">&lt;xsl:with-param&gt;</a></h1>
<ul class="content">
<li class="attr-ref required">name <span class="type"><span class="general">string</span></span>
</li>
<li class="attr-ref">select <span class="type"><span class="general">expression</span></span> <span class="type"><span class="general"></span></span>
</li>
</ul></section></section><section id="xpath-functions"><h1>XPath functions</h1>
<section class="function" id="boolean"><h1><a href="#boolean">boolean(<span class="arglist"><span class="arg-ref required">condition</span></span>)</a></h1>
<div class="desc">
			<p>Convert the <var class="attr-ref">condition</var> expression to either <var class="attr-ref">true()</var> or <var class="attr-ref">false()</var>.</p>
			<p>An empty string, an empty nodeset or the number 0 returns <var class="attr-ref">false()</var>, anything else returns <var class="attr-ref">true()</var>.</p>
			<p class="note">
				Watch out for these pitfalls: ALL of these return <var class="attr-ref">true()</var> when used in an expression that expects a boolean result,
				e.g., in the <var class="attr-ref">test</var> attribute of a <a href="#when" class="elem-ref">when</a> or an <a href="#if" class="elem-ref">if</a> element: "1", "0", "true", "false"
			</p>
		</div></section><section class="function" id="concat"><h1><a href="#concat">concat(<span class="arglist"><span class="arg-ref required">string1</span>, <span class="arg-ref required">string2</span>, <span class="arg-ref">[stringNâ€¦]</span></span>)</a></h1>
<div class="desc">
			<p>Returns a string by concatenating the string value of all arguments</p>
		</div></section><section class="function" id="contains"><h1><a href="#contains">contains(<span class="arglist"><span class="arg-ref required">source</span>, <span class="arg-ref required">find</span></span>)</a></h1>
<div class="desc">
			<p>
				Returns <var class="attr-ref">true()</var> if the <var class="attr-ref">source</var> string contains the <var class="attr-ref">find</var> string.
				Otherwise, it returns <var class="attr-ref">false().</var>
			</p>
		</div></section><section class="function" id="count"><h1><a href="#count">count(<span class="arglist"><span class="arg-ref required">source</span></span>)</a></h1>
<div class="desc">
			<p>Returns the number of nodes in the <var class="attr-ref">source</var> nodeset</p>
			<p class="note">
				Often mistakenly used to check if a nodeset has any nodes, e.g.:
				<code>&lt;xsl:if test="count($children) &amp;gt; 0"&gt;</code> which is not necessary at all,
				simply testing the nodeset itself will return <var class="attr-ref">true()</var> if it has any nodes,
				and <var class="attr-ref">false()</var> if it's empty - e.g.: <code>&lt;xsl:if test="$children"&gt;</code>
			</p>
		</div></section><section class="function" id="current"><h1><a href="#current">current(<span class="arglist"></span>)</a></h1>
<div class="desc">
			<p>Returns the current node</p>
		</div></section><section class="function" id="document"><h1><a href="#document">document(<span class="arglist"><span class="arg-ref required">URL</span>, <span class="arg-ref">[base]</span></span>)</a></h1>
<div class="desc">
			<p>
				Returns a nodeset pointing at the root node ("/") of the document found at the
				specified <var class="attr-ref">URL</var>. 
			</p>
		</div></section><section class="function" id="false"><h1><a href="#false">false(<span class="arglist"></span>)</a></h1>
<div class="desc">
			<p>Returns the boolean value <strong>false</strong></p>
		</div></section><section class="function" id="format-number"><h1><a href="#format-number">format-number(<span class="arglist"><span class="arg-ref required">number</span>, <span class="arg-ref required">pattern</span>, <span class="arg-ref">[decimal-format]</span></span>)</a></h1></section><section class="function" id="function-available"><h1><a href="#function-available">function-available(<span class="arglist"><span class="arg-ref required">function</span></span>)</a></h1>
<div class="desc">
			<p>Returns <var class="attr-ref">true()</var> if a function with the specified name exists.</p>
			<p class="note">
				You should include the prefix if the function is defined in another namespace, e.g.:
				<code>function-available('msxsl:node-set')</code>
			</p>
		</div></section><section class="function" id="generate-id"><h1><a href="#generate-id">generate-id(<span class="arglist"><span class="arg-ref">[node]</span></span>)</a></h1>
<div class="desc">
			<p>Returns a unique string ID for the selected node (or the current node if none specified).</p>
		</div></section><section class="function with-sample" id="id"><h1><a href="#id">id(<span class="arglist"><span class="arg-ref required">ids</span></span>)</a></h1>
<div class="desc">
			<p>
				If the nodes in your document has a unique ID attribute (defined in the DOCTYPE), you can
				use the <a href="#id" class="elem-ref">id</a> function to select them with. The <var class="attr-ref">ids</var> argument takes a whitespace
				separated string of IDs or a nodeset to take values from, and returns a nodeset containing all
				of the nodes referenced by their IDs.
			</p>
		</div>
<div class="sample">
		<pre><code>&lt;!-- Grab three specific nodes by their IDs --&gt;
&lt;xsl:variable name="static" select="id('4815 1623 4200')" /&gt;

&lt;!-- Grab any node referenced in a `&lt;nodeId&gt;` child --&gt;
&lt;xsl:variable name="dynamic" select="id(nodeId)" /&gt;</code></pre>
	</div></section><section class="function" id="key-function"><h1><a href="#key-function">key(<span class="arglist"><span class="arg-ref required">name</span>, <span class="arg-ref required">value</span></span>)</a></h1>
<div class="desc">
			<p>
				Returns a node set of all the nodes in the <var class="attr-ref">name</var> index,
				with the value <var class="attr-ref">value</var> stored.
				Used in conjunction with the <a href="#key" class="elem-ref">key</a> element to facilitate
				fast and easy lookups in the source XML.
			</p>
		</div></section><section class="function" id="local-name"><h1><a href="#local-name">local-name(<span class="arglist"><span class="arg-ref">[source]</span></span>)</a></h1>
<div class="desc">
			<p>Returns the name of the current node or the first node in the specified node set - without the namespace prefix</p>
		</div></section><section class="function" id="name"><h1><a href="#name">name(<span class="arglist"><span class="arg-ref">[source]</span></span>)</a></h1>
<div class="desc">
			<p>Returns the name of the current node or the first node in the specified node set</p>
		</div></section><section class="function with-sample" id="normalize-space"><h1><a href="#normalize-space">normalize-space(<span class="arglist"><span class="arg-ref">[source]</span></span>)</a></h1>
<div class="desc">
			<p>
				Returns a copy of the <var class="attr-ref">source</var> string with leading and trailing space removed, as well as
				compressing runs of whitespace characters into a single space.
			</p>
		</div>
<div class="sample">
		<code>normalize-space('  a   little  tiny space   ')</code> returns: <code>a little tiny space</code>
	</div></section><section class="function" id="number-function"><h1><a href="#number-function">number(<span class="arglist"><span class="arg-ref required">source</span></span>)</a></h1>
<div class="desc">
			<p>Convert a nodeset, boolean value or string to a number</p>
		</div></section><section class="function" id="position"><h1><a href="#position">position(<span class="arglist"></span>)</a></h1>
<div class="desc">
			<p>Returns the current node's index (1-based) within the <em>current nodelist</em>.</p>
		</div></section><section class="function" id="processing-instruction-function"><h1><a href="#processing-instruction-function">processing-instruction(<span class="arglist"><span class="arg-ref">[name]</span></span>)</a></h1>
<div class="desc">
			<p>Returns a nodeset of the current context node's Processing Instruction children - if a <var class="attr-ref">name</var> is specified,
			the list is filtered to only include those matching that.</p>
		</div></section><section class="function" id="string"><h1><a href="#string">string(<span class="arglist"><span class="arg-ref required">value</span></span>)</a></h1>
<div class="desc">
			<p>Convert a value (nodeset, number, boolean or another string) to a <var class="attr-ref">string</var> value</p>
			<p class="note">Converting a nodeset to a string <em>will only return the string value of the first node in the set.</em>
			</p>
		</div></section><section class="function" id="string-length"><h1><a href="#string-length">string-length(<span class="arglist"><span class="arg-ref required">string</span></span>)</a></h1>
<div class="desc">
			<p>Returns the number of characters in the <var class="attr-ref">string</var>.</p>
		</div></section><section class="function" id="substring"><h1><a href="#substring">substring(<span class="arglist"><span class="arg-ref required">string</span>, <span class="arg-ref required">start</span>, <span class="arg-ref">[length]</span></span>)</a></h1>
<div class="desc">
			<p>
				Returns part of (a) <var class="attr-ref">string</var> starting at <var class="attr-ref">start</var>, spanning at most <var class="attr-ref">length</var> characters.
				If <var class="attr-ref">length</var> isnâ€™t specified, the rest of the string from index <var class="attr-ref">start</var> will be returned.
			</p>
			<p class="note">
				Indexes in XPath/XSLT are 1-based, so the first character in a string can be found with: <code>substring($string, 1, 1)</code> 
			</p>
		</div></section><section class="function" id="substring-after"><h1><a href="#substring-after">substring-after(<span class="arglist"><span class="arg-ref required">source</span>, <span class="arg-ref required">find</span></span>)</a></h1>
<div class="desc">
			<p>Returns the rest of the <var class="attr-ref">source</var> string, following the <var class="attr-ref">find</var> string.</p>
		</div></section><section class="function" id="substring-before"><h1><a href="#substring-before">substring-before(<span class="arglist"><span class="arg-ref required">source</span>, <span class="arg-ref required">find</span></span>)</a></h1>
<div class="desc">
			<p>Returns everything that comes before the <var class="attr-ref">find</var> string inside the <var class="attr-ref">source</var> string.</p>
		</div></section><section class="function" id="translate"><h1><a href="#translate">translate(<span class="arglist"><span class="arg-ref required">source</span>, <span class="arg-ref required">find</span>, <span class="arg-ref required">replace</span></span>)</a></h1>
<div class="desc">
			<p>
				Performs character-replacements in the <var class="attr-ref">source</var> string, by replacing every character in the
				<var class="attr-ref">find</var> argument found in <var class="attr-ref">source</var>, with the character in <var class="attr-ref">replace</var> at
				the same index </p>
		</div></section><section class="function" id="true"><h1><a href="#true">true(<span class="arglist"></span>)</a></h1>
<div class="desc">
			<p>Returns the boolean value <strong>true</strong></p>
		</div></section></section><a href="https://github.com/greystate/XSLT-Reference#readme"><img class="forkme" src="http://aral.github.com/fork-me-on-github-retina-ribbons/right-orange@2x.png" alt="Fork me on GitHub"></a><nav class="toc-link"><a href="#toc" title="Show a simplified table of contents">Summary</a><a href="#xslt-elements">Elements</a><a href="#xpath-functions">Functions</a><a class="feed" href="dash-feed://http%3A%2F%2Fpimpmyxslt.com%2Freference%2Fxslt-quick-reference.xml" title="Subscribe to feed for Dash here">Dash Feed</a></nav>
</body>
</html>
